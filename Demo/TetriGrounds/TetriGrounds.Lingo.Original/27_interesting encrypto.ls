-- Lingo Encryption Method--Date: Mon Apr  1 09:22:54 MST 2002--From: David Dantowitz <david@dantowitz.com>--Subject: Lingo Encryption Method-- Lingo Source code for manipulation of 32-bit integers, binary strings,-- and hexadecimal strings.---- Also includes code fast CRC computation---- Written and placed in the public domain by David Dantowitz, March 29, 2002-- david@dantowitz.com--on setup -- initialize the CRC Table and the digit string for base64 triplets  global gCRCTable  global gDigits    gDigits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"    if voidP(gCRCTable) then     gCRCTable = makeCRCTable(dohextoint("edb88320"))  end if  endon doHexToInt hex -- return a 32-bit integer    --  hex = "ffffffff"  --  hex = "00000010"  --  hex = "d1310ba6"    v = 0    repeat with i = 1 to 8    c = charToNum(char i of hex)        if c >= 97 then v = v*16 + c-87    else if c >= 65 then v = v*16 + c-55    else v = v*16 + c-48      end repeat    return vendon doIntToHex int -- return an 8 digit hex string    v = ""    mask = 15  modVal = 1    repeat with i = 1 to 7        d = bitand(int, mask)    d = d / modVal        if d < 10 then v = numToChar(d + 48) & v    else v = numToChar(d + 87) & v        mask =  mask * 16    modVal = modVal * 16      end repeat    --  --  -- Do last four bits by "hand"  --    mask = 268435456  bitVal = 1  temp = 0    repeat with i = 1 to 4    d = bitand(int, mask)    if d <> 0 then temp = temp + bitVal        bitVal = bitVal + bitVal    mask = mask + mask      end repeat    if temp < 10 then v = numToChar(temp + 48) & v  else v = numToChar(temp + 87) & v      return v  endon doIntToBytes int -- break a 32-bit integer into 4 bytes    byteList = []    if int < 0 then     setAt(byteList, 1, 128+bitand(int, 2130706432)/16777216)  else    setAt(byteList, 1, bitand(int, 2130706432)/16777216)  end if        setAt(byteList, 2, bitand(int, 16711680)/65536)    setAt(byteList, 3, bitand(int, 65280)/256)    setAt(byteList, 4, bitand(int, 255))    return byteList  endon unsignedAdd x, y  res = bitand(x, 2147483647) + bitand(y, 2147483647) -- mask off the lower 31 bits    if (x < 0 and y > 0) or (x > 0 and y < 0) then    res = bitxor(res, -2147483648)    end if    return resendon doCRC_slower string, oldCRC, poly -- bit at a time (used to build byte table)  len = length(string)    repeat with j = 1 to len    oldCRC = bitxor(oldCRC, charToNum(char j of string))        repeat with i = 1 to 8            if bitand(oldCRC, 1) then        oldCRC = bitxor(shiftRight(oldCRC), poly)      else        oldCRC = shiftRight(oldCRC)      end if          end repeat      end repeat    return oldCRC  end doCRC_sloweron doCRCTable string, oldCRC -- byte at a time  global gCRCTable    len = length(string)    repeat with j = 1 to len        oldCRC = bitxor(oldCRC, charToNum(char j of string))        if oldCRC > 0 then       upper3 = oldCRC / 256    else -- deal with high bit set      upper3 = 8388608 + bitand(oldCRC, 2147483392)/256 -- doHexToInt("00800000") anddoHexToInt("7fffff00")        end if        oldCRC = bitxor(upper3, getAt(gCRCTable, 1+bitand(oldCRC, 255)))      end repeat    return oldCRC  end doCRCTable------ make a table for a polynomial (use only "known" polynomials with good properties--on makeCRCTable poly   theTable = []    repeat with i = 0 to 255     crc = doCRC_slower(numToChar(i), 0, poly)      append theTable, crc  end repeat    return theTableend makeCRCTableon shiftRight n -- shift right one bit  l = doIntToBytes(n)    b = getAt(l, 4)  res = b/2    b = getAt(l, 3)  res = res + b*128    b = getAt(l, 2)  res = res + b*32768 -- 128*256    b = getAt(l, 1)  res = res + b*18388608 -- 28*256*256    return res  end shiftRight------ Handy for base64 encoding--on TripletToQuad a, b, c  global gDigits          -- gDigits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"  --    q1 = (a & 0xfC) >> 2;        q1 = bitand(a, 252) / 4    --    q2 = (a & 0x03) << 4;         q2 = bitand(a, 3) * 16  --    q2 += (b & 0xf0) >> 4;        q2 = q2 + bitand(b, 240) /16    --    q3 = (b & 0x0f) << 2;        q3 = bitand(b, 15) * 4  --    q3 += (c & 0xc0) >> 6;        q3 = q3 + bitand(c, 192) / 64          --    q4 = (c & 0x3f);        q4 = bitand(c, 63)    q1234 = char (q1+1) of gDigits  q1234 = q1234 & char (q2+1) of gDigits  q1234 = q1234 & char (q3+1) of gDigits  q1234 = q1234 & char (q4+1) of gDigits    return q1234  end on QuadToTriplet q1234  --  lookUpDigit = ["3E", "FF", "FF", "FF", "3F", "34", "35", "36", "37", "38", "39",--"3A", "3B", "3C", "3D", "FF", "FF", "FF", "FF", "FF", "FF", "FF", "00", "01", "02",--"03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10",--"11", "12", "13", "14", "15", "16", "17", "18", "19", "FF", "FF", "FF", "FF", "FF",--"FF", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26",--"27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33"]  --  c = count(lookUpDigit)  --    --  put lookUpDigit  --  repeat with i = 1 to c  --    setAt(lookUpDigit, i, doHexToInt("000000" & getAt(lookUpDigit, i)))  --  end repeat  --    --    --  put lookUpDigit    lookUpDigit = [62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255,\255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30,\31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]  plusNum = charToNum("+")    --    temp = *quad - '+';  temp = charToNum(char 1 of q1234) - plusNum  --    *a = lookUpDigit[temp] << 2;  a = getAt(lookUpDigit, temp+1)*4      --    temp = *(quad+1) - '+';  temp = charToNum(char 2 of q1234) - plusNum  --    temp = lookUpDigit[temp];  temp = getAt(lookUpDigit, temp+1)      --    *a += temp >> 4;  a = a + temp/16      --    *b = (temp & 0x0f) << 4;  b = bitand(temp, 15)*16    --    temp = *(quad+2) - '+';  temp = charToNum(char 3 of q1234) - plusNum  --    temp = lookUpDigit[temp];  temp = getAt(lookUpDigit, temp+1)  --    *b += temp >> 2;  b = b + temp/4    --    *c = (temp & 0x03) << 6;  c = bitand(temp, 3) * 64    --    temp = *(quad+3) - '+';  temp = charToNum(char 4 of q1234) - plusNum  --    temp = lookUpDigit[temp];  temp = getAt(lookUpDigit, temp+1)  --    *c += temp;  c = c + temp    return [a, b, c]end on testQuads  repeat with i = 1 to 10000        a = random(256)-1    b = random(256)-1    c = random(256)-1        r = quadToTriplet(tripletToQuad(a, b, c))        if getAt(r, 1) <> a or getAt(r, 2) <> b or getAt(r, 3) <> c then        put "Error: " & a && b && c && r    end if      end repeatendon hexToBinString str -- 8 char hex to 4 byte binary string  len = length(str)    upperA = charToNum("A")  upperF = charToNum("F")    lowerA = charToNum("a")  lowerF = charToNum("f")    num0 = charToNum("0")  num9 = charToNum("9")  res = ""    repeat with i = 1 to len    n1 = charToNum(char i of str)        if n1 >= upperA and n1 <= upperF then      v = n1-upperA + 10    else     if n1 >= lowerA and n1 <= lowerF then      v = n1-lowerA + 10    else     if n1 >= num0 and n1 <= num9 then      v = n1-num0    else      v = 0    end if        v = v * 16        i = i + 1        n1 = charToNum(char i of str)        if n1 >= upperA and n1 <= upperF then      v = v + n1-upperA + 10    else     if n1 >= lowerA and n1 <= lowerF then      v = v + n1-lowerA + 10    else     if n1 >= num0 and n1 <= num9 then      v = v + n1-num0    end if        res = res & numToChar(v)      end repeat    return res  end hexToBinStringon binToHexString str -- 4 byte binary string to 8 char hex string  len = length(str)    res = ""  digits = "0123456789ABCDEF"      repeat with i = 1 to len    c = charToNum(char i of str)    n = c/16    res = res & char (n+1) of digits    n = bitand(15, c)    res = res & char (n+1) of digits      end repeat    return res  end binToHexStringon intToBinString i -- 32-bit integer to a 4 byte binary string  arr = doIntToBytes(i)    return numToChar(getAt(arr, 1)) & numToChar(getAt(arr, 2)) & numToChar(getAt(arr, 3))& numToChar(getAt(arr, 4))end intToBinStringon binStringToInt bStr -- 4 byte binary string to 32-bit integer  res = charToNum(char 1 of bStr)  res = res*256 + charToNum(char 2 of bStr)    res = res*256 + charToNum(char 3 of bStr)  res = res*256 + charToNum(char 4 of bStr)    return resend binStringToInt 