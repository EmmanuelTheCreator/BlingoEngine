global gSpriteManagerproperty myGfx -- pointerproperty myBlocks -- pointerproperty myScoreManager -- pointerproperty MySubBlocks -- used for all spritenums that are used by his blockproperty myMemberName property myX,myY,myWidthproperty myMaxX,myMaxYproperty myDownPressed,myMovingproperty mySlowDown,myWaiter,mySlowDownFactorByLevelproperty myTypeBlocksproperty myFinished -- if the game is finishedproperty myLastKey,myKeyBoardWaiter,myKeyBoardTotproperty myBlockTypeproperty MyNextBlocks,myNextBlockType,MyNextBlockHor,MyNextBlockVer -- the next block that will comeproperty myPauseproperty myStopKeyActionon new me,_Gfx,_Blocks,_ScoreManager,_width,_height  if voidp(_width) then alert "no width given on playerBlock"  if voidp(_height) then alert "no height given on playerBlock"  myBlocks = _Blocks  myScoreManager = _ScoreManager  MySubBlocks = []  MyNextBlocks =[]  myMemberName="Block1"  myMaxX = _width  myMaxY = _height  me.AddTypeBlock([[0,0],[-1,0],[1,0],[0,-1]],true) -- 'T' Block, true-false = rotate(else its flip axis)  me.AddTypeBlock([[0,0],[-1,0],[-2,0],[1,0]],true) -- '-' Block  me.AddTypeBlock([[-1,-1],[0,-1],[0,0],[1,0]],false) -- 'z' Block  me.AddTypeBlock([[1,-1],[0,-1],[0,0],[-1,0]],false) -- 'z' Block invers  me.AddTypeBlock([[0,-1],[1,-1],[0,0],[1,0]],false) -- '#' Block Cubus  me.AddTypeBlock([[-1,-1],[-1,0],[0,0],[1,0]],true) -- 'L' Block   me.AddTypeBlock([[1,-1],[-1,0],[0,0],[1,0]],true) -- 'L' Block  invers    myGfx = _Gfx  myX =myMaxX/2  myY =2  myWidth = 1  myMoving= false  _level = myScoreManager.GetLevel()    me.calculatespeed()  if mySlowDown<=1 then mySlowDown=1  myWaiter= 0  myKeyBoardWaiter =0  myKeyBoardTot = 11  myNextBlockType = 1  MyNextBlockHor = 16  MyNextBlockVer = 13  mySlowDownFactorByLevel = 10  me.UpdateNextBlock()  me.StartMove()  myStopKeyAction = false  return meendon calculatespeed me  _level = myScoreManager.GetLevel()  mySlowDownFactorByLevel = 10  mySlowDown = 65  repeat with i=0 to _level    mySlowDownFactorByLevel=mySlowDownFactorByLevel-1    if mySlowDownFactorByLevel<=3 then mySlowDownFactorByLevel=2    if mySlowDown>1 then mySlowDown=mySlowDown-(mySlowDownFactorByLevel)  end repeat    put mySlowDown,mySlowDownFactorByLevelendon keyyed me,val  if myPause =false then    myKeyBoardWaiter =0    myLastKey=val    me.MoveBlock(val)  end ifendon PauseGame me  if myPause = true then    sprite(35).blend = 0    myPause =false  else    sprite(35).blend = 100    sprite(35).LocZ = 10010    myPause =true  end ifendon MoveBlock me,val    if myFinished =true then exit        -- right  if val =2 then     me.rightt()    myDownPressed = false  else if val =4 then    me.leftt()    myDownPressed = false  else if val =3 then    if myStopKeyAction = false then      -- down      myDownPressed = true    else      myDownPressed = false    end if  else if val =9 then    -- nothing    myDownPressed = false    myStopKeyAction = false  else if val =1 then    -- up    me.turnBlock()    myDownPressed = false      end ifendon LetBlockFall me  starting = myY  repeat with i=starting to myMaxY    test = me.downCheck()    me.refreshBlock()    if test =false then exit repeat  end repeatendon stepframe me  if myPause =false then    if myLastKey<=4 and myLastKey<>1 then      if myKeyBoardWaiter>myKeyBoardTot then        myKeyBoardWaiter=0        me.MoveBlock(myLastKey)      end if      myKeyBoardWaiter = myKeyBoardWaiter+1    end if    Addon=0    if myDownPressed = true then Addon = mySlowDown    if myWaiter+Addon>mySlowDown then      myWaiter = 0      me.downCheck()      me.refreshBlock()    else      myWaiter = myWaiter +1    end if  end ifendon downCheck me  check =me.collitionDetect(myX,myY+1)  if check= true then    me.freezeBlock()    me.resetBlock()    return false  else    myY=myY+1    return true  end ifendon resetBlock me  if myFinished=false then    repeat with i in MySubBlocks      _y = i[#yy]+myY      check = myBlocks.FullHorizontal(_y)      if check = true then        myBlocks.RemoveHorizontal(_y)      end if    end repeat    myStopKeyAction = true    me.destroyBlock()    me.createBlock()    myY=2    myX =myMaxX/2    me.myScoreManager.BlockFrozen() -- add score when you freeze a block    me.myScoreManager.AddDropedBlock() -- add that there's a block dropped    -- check if we go a level up    levelup =me.myScoreManager.GetLevelUp()    if levelup=true then      me.calculatespeed()    end if        check = me.collitionDetect(myX,myY)    if check=true then       -- game finished      myScoreManager.GameFinished()      myFinished=true      myBlocks.FinishedBlocks()      me.StopMove()      sendsprite(1 ,#GameFinished,myScoreManager.GetScore())    end if  end ifendon freezeBlock me  if myFinished=false then    repeat with i=1 to MySubBlocks.count      check = myBlocks.NewBlock(myX+MySubBlocks[i][#xx],myY+MySubBlocks[i][#yy],myBlockType)          end repeat  end ifendon collitionDetect me,_x,_y  repeat with i=1 to MySubBlocks.count    if myBlocks.IsBlock(_x+MySubBlocks[i][#xx],_y+MySubBlocks[i][#yy])=true then      return true      exit repeat      exit    end if  end repeat  return falseend on turnBlock me  myWaiter = myWaiter+1  offsetX =0  tempBlock =[]  collition = false  -- prepare rotation  repeat with i=1 to MySubBlocks.count    oldx = MySubBlocks[i][#xx]    oldy = MySubBlocks[i][#yy]    newy =  oldx    newx = -oldy    tempBlock.append([newx,newy])    -- check if the block isnt over border, then move it back with 'offset'    -- right    --    if myX+newX > myMaxX-1 then    --      -- check if the new offset will be bigger    --      if offsetX<newX then     --        offsetX=-newX    --      end if    --    else if myX+newX <= 0 then    --      --left    --      -- check if the new offset will be bigger    --      if offsetX>newX then     --        offsetX=-newX    --      end if    --    end if    if myX+newX > myMaxX-1 then collition=true    -- colition check    check = myBlocks.IsBlock(myX+newx+offsetX,myY+newy)    if check=true then collition=true  end repeat    if collition=false then    -- aply new rotation    repeat with i=1 to MySubBlocks.count      MySubBlocks[i][#xx] = tempBlock[i][1]      MySubBlocks[i][#yy] = tempBlock[i][2]    end repeat  end if      myX = myX + offsetX     me.refreshBlock()end----------------------------------------on rightt me  myWaiter = myWaiter+1  check =me.collitionDetect(myX+1,myY)  if check= false then    -- calculate max right from block    maxright = 0    repeat with i=1 to MySubBlocks.count      tempx = MySubBlocks[i][#xx]      if tempx>maxright then maxright = tempx    end repeat    if myX+maxright+1 < myMaxX then      myX = myX +1      me.refreshBlock()    end if  end ifendon leftt me  myWaiter = myWaiter+1  -- left  -- left colition  check =me.collitionDetect(myX-1,myY)  if check= false then    -- calculate max left from block    maxleft = 0    repeat with i=1 to MySubBlocks.count      tempx = MySubBlocks[i][#xx]      if tempx<maxleft then maxleft = tempx    end repeat    if myX-1+maxleft > 0 then      myX = myX -1      me.refreshBlock()    end if  end ifend----------------------------------------on StartMove me  add the actorlist(me)  myMoving = trueendon StopMove me  deleteone the actorlist(me)  myMoving = falseend----------------------------------------on refreshBlock me  repeat with i = 1 to MySubBlocks.count    myGfx.PositionBlock(MySubBlocks[i][#obj].getSpriteNum(),myX+MySubBlocks[i][#xx],myY+MySubBlocks[i][#yy])  end repeatend----------------------------------------------------------on createBlock me    myBlockType = myNextBlockType  chosenBlock = myTypeBlocks[myBlockType]  --    chosenBlock = myTypeBlocks[2]  -- create subBlocks  repeat with i=1 to chosenBlock[1].count    MySubBlocks.append([:])    MySubBlocks[i][#obj] = script("Block").new(myGfx,myBlockType)    MySubBlocks[i][#obj].createBlock()    MySubBlocks[i][#xx] = chosenBlock[1][i][1]    MySubBlocks[i][#yy] = chosenBlock[1][i][2]    MySubBlocks[i][#rotating] = chosenBlock[2][1]  end repeat  me.refreshBlock()  me.UpdateNextBlock()endon UpdateNextBlock me  me.destroyNextBlock()  -- create new  myNextBlockType=random(myTypeBlocks.count)  chosenBlock = myTypeBlocks[myNextBlockType]  repeat with i=1 to chosenBlock[1].count    MyNextBlocks.append([:])    MyNextBlocks[i][#obj] = script("Block").new(myGfx,myNextBlockType)    MyNextBlocks[i][#obj].createBlock()    MyNextBlocks[i][#xx] = chosenBlock[1][i][1]    MyNextBlocks[i][#yy] = chosenBlock[1][i][2]    MyNextBlocks[i][#rotating] = chosenBlock[2][1]    myGfx.PositionBlock(MyNextBlocks[i][#obj].getSpriteNum(),MyNextBlockHor+MyNextBlocks[i][#xx],MyNextBlockVer+MyNextBlocks[i][#yy])  end repeatendon destroyNextBlock me  -- destroy previous  repeat with i in MyNextBlocks    i[#obj].Destroy()    i[#obj]=0    i[#xx]=0    i[#yy]=0  end repeat  MyNextBlocks =[]end----------------------------------------------------------on GetPause me  return myPauseendon destroyBlock me  repeat with i in MySubBlocks    i[#obj].Destroy()    i[#obj]=0    i[#xx]=0    i[#yy]=0  end repeat  MySubBlocks =[]end-------------------on AddTypeBlock me,val,_rotate  if voidp(myTypeBlocks) then myTypeBlocks =[]  myTypeBlocks.append([val,[_rotate]])end-------------------on destroy me   me.destroyNextBlock()  me.destroyBlock()  me.StopMove()  myGfx =0  myBlocks =0  myScoreManager =0end